<?phpnamespace App\Services\Client\Actions\Order;use App\Models\Client;use App\Models\ClientAddress;use App\Models\ClientBonus;use App\Models\Order;use App\Models\OrderProduct;use App\Models\OrderProductItem;use App\Models\Product;use App\Models\ProductPrice;use App\Enums as Enums;use App\Models\Promocode;use App\Services\Client\Contracts\StoreOrder;use App\Services\Client\Dto\Order\StoreDto;use Illuminate\Support\Facades\Auth;use Illuminate\Support\Facades\DB;use Symfony\Component\Finder\Exception\AccessDeniedException;use Throwable;use App\Tasks as Tasks;class StoreAction implements StoreOrder{    /**     * @throws Throwable     */    public function execute(StoreDto $dto): void    {        /** @var Client $client */        $client = Auth::user()->client;        $address = ClientAddress::find($dto->address_id);        $promocode = !empty($dto->promocode) ? app(Tasks\Promocode\FindPromocodeByCodeTask::class)->run($dto->promocode) : null;        $this->ensureProductsTypeIsNotGame($dto);//PRODUCT TYPE != GAME        $this->ensureProductsPricesMatches($dto); // PRODUCT PRICE NOT EQUALS        $this->ensureProductsQuantityIsSufficient($dto); // DISADVANTAGE OF THE PRODUCT        $this->ensureAddressIsExistsAndBelongsToClient($client, $address); // ADDRESS NOT TRUE        $this->ensurePromocodeIsExists($dto, $promocode); // PROMOCODE NOT TRUE        $this->ensurePromocodeQuantityIsSufficient($dto, $promocode); //DELETE PROMOCODE        $daysCount = $this->ensureProductsDaysCountIsSameAndReturnDaysCount($dto); //        DB::transaction(function () use ($client, $address, $dto, $promocode, $daysCount) {            $amount = $this->calculateTotalAmount($client, $dto, $promocode);            $bonus = $this->calculateBonus($dto);            $order = $this->createOrder($client, $address, $amount, $bonus, $daysCount);            $this->createOrderProducts($dto, $order);        });    }    private function createOrder(Client $client, ClientAddress $address, int $amount, ?int $bonus, int $daysCount): Order    {//        dd($client->id);        return Order::create([            'client_id' => $client->id,            'courier_id' => 1,            'city_id' => $address->city->id,            'street' => $address->street,            'building' => $address->building,            'apartment' => $address->apartment,            'amount' => $amount,            'retrieve_bonus' => $bonus,            'days_count' => $daysCount,            'ordered_at' => now(),            'status' => Enums\Order\Status::CREATED,        ]);    }    private function createOrderProducts(StoreDto $dto, Order $order): void    {        foreach ($dto->products as $orderProduct) {            $product = Product::find($orderProduct['product_id']);            $productPrice = ProductPrice::find($orderProduct['price_id']);            $orderProduct = OrderProduct::create([                'order_id' => $order->id,                'product_id' => $product->id,                'name' => $product->name,                'price' => $productPrice->price,                'quantity' => $orderProduct['quantity'] ?? 1,            ]);            $product->update([                'quantity' => $product->quantity - $orderProduct['quantity']            ]);            if ($product->type == Enums\Product\Type::SET) {                $this->createOrderProductItems($product, $orderProduct);            }        }    }    private function createOrderProductItems(Product $set, $orderProduct): void    {        $subproducts = $set->subproducts()->withPivot('quantity')->get();        foreach ($subproducts as $subproduct) {            if ($subproduct->type == Enums\Product\Type::PRODUCT) {                OrderProductItem::create([                    'order_product_id' => $orderProduct->id,                    'item_id' => $subproduct->id,                    'quantity' => $subproduct->pivot->quantity,                ]);                $subproduct->update([                    'quantity' => $subproduct->quantity - $subproduct->pivot->quantity                ]);            }        }    }    private function createClientBonus(Client $client, $amount): void    {        $client->update([            'amount' => $amount,            'description' => 'Потратил на покупку',        ]);    }    private function ensureAddressIsExistsAndBelongsToClient(Client $client, ?ClientAddress $address): void    {        if (empty($address) || !$client->addresses->contains('id', '=', $address->id)) {            throw new AccessDeniedException(                __('Адрес неверный')            );        }    }    private function calculateTotalAmount(Client $client, StoreDto $dto, ?Promocode $promocode): int    {        $amount = 0;        foreach ($dto->products as $orderProduct) {            $productPrice = ProductPrice::find($orderProduct['price_id']);            $amount += $productPrice->price;        }        if (!empty($promocode)) {            if ($promocode->type == Enums\Promocode\Type::AMOUNT) {                if ($promocode->amount > $amount) {                    $amount = 0;                } else {                    $amount -= $promocode->amount;                }            } elseif ($promocode->type == Enums\Promocode\Type::PERCENT) {                $amount = $amount * $promocode->amount / 100;            }            $promocode->update([                'quantity' => $promocode->quantity - 1,            ]);        }        if ($dto->spend_bonuses && $client->getBonusSum() != 0) {            if ($amount > $client->getBonusSum()) {                $amount -= $client->getBonusSum();                $this->createClientBonus($client, -$client->getBonusSum());                return $amount;            } else {                $this->createClientBonus($client, -$amount);                return 0;            }        }        return $amount;    }    private function ensureProductsQuantityIsSufficient(StoreDto $dto): void    {        foreach ($dto->products as $orderProduct) {            $product = Product::find($orderProduct['product_id']);            if ($orderProduct['quantity'] > $product->quantity) {                throw new AccessDeniedException(                    __('Недостаточно товара.')                );            }        }    }    private function ensureProductsTypeIsNotGame(StoreDto $dto): void    {        foreach ($dto->products as $product) {            $product = Product::find($product['product_id']);            if ($product->type == Enums\Product\Type::GAME) {                throw new AccessDeniedException(                    __('Невозможный тип продукта.')                );            }        }    }    private function ensureProductsPricesMatches(StoreDto $dto): void    {        foreach ($dto->products as $orderProduct) {            $product = Product::find($orderProduct['product_id']);            if (!$product->prices->contains('id', '=', $orderProduct['price_id'])) {                throw new AccessDeniedException(                    __('Неправильная цена.')                );            }        }    }    private function ensurePromocodeIsExists(StoreDto $dto, ?Promocode $promocode): void    {        if (!empty($dto->promocode)) {            if (empty($promocode) || $promocode->quantity <= 0) {                throw new AccessDeniedException(                    __('Промокод неверный.')                );            }        }    }    private function calculateBonus(StoreDto $dto): int    {        $bonus = 0;        foreach ($dto->products as $orderProduct) {            $price = ProductPrice::find($orderProduct['price_id']);            $bonus += $price->bonus;        }        return $bonus;    }    private function ensurePromocodeQuantityIsSufficient(StoreDto $dto, ?Promocode $promocode): void    {        if (!empty($dto->promocode)) {            if ($promocode->quantity <= 0) {                $promocode->delete();                throw new AccessDeniedException(                    __('Промокод неверный.')                );            }        }    }    private function ensureProductsDaysCountIsSameAndReturnDaysCount(StoreDto $dto): int    {        $daysCount = collect();        foreach ($dto->products as $orderProduct) {            $productPrice = ProductPrice::find($orderProduct['price_id']);            $daysCount->push($productPrice->days_count);        }        $result = $daysCount->every(function ($value) use ($daysCount) {            return $value === $daysCount->first();        });        if (!$result) {            throw new AccessDeniedException(                __('Разное количество дней.')            );        }        return $daysCount->first();    }}